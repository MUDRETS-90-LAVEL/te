## Документация по тестовому заданию
# 1. Введение
   Настоящая документация описывает решение тестового задания о добавлении заказов на события с использованием PHP и базы данных MySQL. Задание включает резервирование и подтверждение заказов через сторонний API, а также нормализацию базы данных для учета различных типов билетов.

# 2. Описание проблемы
   Задача заключалась в реализации функции для добавления заказов на события с учетом следующих требований:

Генерация уникального штрих-кода для заказа.
Работа с ненадежным API, который может возвращать результаты случайным образом.
Сохранение информации о заказах в таблице MySQL, которая должна учитывать различные типы билетов.
Нормализация базы данных из-за расширения функционала для учета дополнительных типов билетов.


# 3. Структура базы данных
   3.1 Исходная таблица
```sql
CREATE TABLE orders (
id INT AUTO_INCREMENT PRIMARY KEY,
event_id INT NOT NULL,
event_date DATETIME NOT NULL,
ticket_adult_price INT,
ticket_adult_quantity INT,
ticket_kid_price INT,
ticket_kid_quantity INT,
barcode VARCHAR(120) UNIQUE,
equal_price INT,
created DATETIME DEFAULT CURRENT_TIMESTAMP
);
```
Поля таблицы:
```
id: Уникальный идентификатор заказа.
event_id: Уникальный идентификатор события.
event_date: Дата и время события.
ticket_adult_price: Цена взрослого билета.
ticket_adult_quantity: Количество купленных взрослых билетов.
ticket_kid_price: Цена детского билета.
ticket_kid_quantity: Количество купленных детских билетов.
barcode: Уникальный штрих-код заказа.
equal_price: Общая стоимость заказа.
created: Дата создания заказа.
```

# 3.2 Нормализованная структура базы данных
Создание дополнительных таблиц для учета разных типов билетов:
```
CREATE TABLE ticket_types (
id INT AUTO_INCREMENT PRIMARY KEY,
name VARCHAR(50) NOT NULL,
price INT NOT NULL
);

CREATE TABLE tickets (
id INT AUTO_INCREMENT PRIMARY KEY,
order_id INT,
ticket_type_id INT,
quantity INT,
barcode VARCHAR(120) UNIQUE,
FOREIGN KEY (order_id) REFERENCES orders(id),
FOREIGN KEY (ticket_type_id) REFERENCES ticket_types(id)
);
```
Поля новой схемы:
```
ticket_types: Таблица для хранения типов билетов с их названиями и ценами.
tickets: Таблица для хранения информации о каждом отдельном билете в заказе, включая уникальные штрих-коды для каждого билета.
```
## 4. Реализация функций
   4.1 Генерация уникального штрих-кода
   Функция для генерации уникального 8-значного штрих-кода:
```
function generateUniqueBarcode() {
return strval(rand(10000000, 99999999));
}
```

# 4.2 Бронирование заказа
Функция для добавления заказа в базу данных:

```
function addOrder($event_id, $event_date, $ticket_adult_price, $ticket_adult_quantity, $ticket_kid_price, $ticket_kid_quantity, $conn) {
// Логика бронирования, отправка запросов на API, создание заказа в БД
}
```

Основные этапы функции:
Генерация шкалы на основе данных заказа.
Отправка данных для бронирования на сторонний API.
Обработка возможных ошибок и повторная генерация штрих-кодов при необходимости.
Отправка подтверждения о бронировании и, если успешно, сохранение данных заказа в базе данных.
# 4.3 Работа со сторонним API
Функции для отправки запросов на бронирование и подтверждение заказа:
```
function sendBookingRequest($data) {
// Мокаем ответ API, возвращаем случайный ответ
}

function sendApprovalRequest($barcode) {
// Мокаем ответ API, возвращаем случайный ответ
}
```
# 5. Заключение
   В результате проведенной работы была реализована эффективная система управления заказами на события с учетом требований нормализации базы данных. В процессе работы учитывались различные бизнес-логики и возможные сценарии, что позволило создать надежное решение, готовое к дальнейшему развитию.
